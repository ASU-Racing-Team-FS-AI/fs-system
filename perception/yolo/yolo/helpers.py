"""
Helper Functions
"""
import numpy as np

from asurt_msgs.msg import BoundingBoxes, BoundingBox, ConeImg, ConeImgArray
from cv_bridge import CvBridge

def processBboxes(boxes: list, view_id: int) -> BoundingBoxes:
    """
    Processes a list of bounding boxes generated by a detector into a standardized format.

    Args:
        boxes (list): List of detections returned by the detector, where each detection is an object 
                    with attributes like 'conf', 'xyxy', 'xywh', and 'cls'.
        view_id (int): Identifier of the frame associated with the detections.

    Returns:
        BoundingBoxes: An object containing processed bounding box information.
            - view_id (int): The frame ID associated with the detections.
            - object_count (int): Number of detected objects.
            - bounding_boxes (list of BoundingBox): List of detected bounding boxes, where each
            BoundingBox object contains attributes like 'probability', 'xmin', 'ymin', 'xmax',
            'ymax', 'x_center', 'y_center', 'width', 'height', 'detection_id', 'track_id', and 'type'.
    """
    detections = BoundingBoxes()

    detections.view_id = int(view_id)
    detections.object_count = len(boxes)
    detections.bounding_boxes = [] 

    for idx, box in enumerate(boxes):
        
        detection = BoundingBox()
        detection.probability = float(box.conf[0])
        
        detection.xmin = int(box.xyxy[0][0])
        detection.ymin = int(box.xyxy[0][1])
        detection.xmax = int(box.xyxy[0][2])
        detection.ymax = int(box.xyxy[0][3])
        detection.x_center = int(box.xywh[0][0])
        detection.y_center = int(box.xywh[0][1])
        detection.width = int(box.xywh[0][2])
        detection.height = int(box.xywh[0][3])

        detection.detection_id = idx
        detection.track_id = 0 #yet to be tracked - track ids are 1-indexed
        detection.type = int(box.cls[0])

        detections.bounding_boxes.append(detection)  
    
    return detections

def cropBboxes(img: np.ndarray, boxes: list, view_id: int, bridge: CvBridge) -> ConeImgArray:
    """
    Crops regions of interest (ROIs) from an input image based on provided bounding boxes.

    Args:
        img (np.ndarray): The input image from which ROIs will be cropped.
        boxes (list): List of bounding boxes specifying regions to be cropped from the image.
                    Each bounding box should contain attributes like 'xyxy' representing 
                    coordinates in the format [xmin, ymin, xmax, ymax].
        view_id (int): Identifier of the frame associated with the detections.

    Returns:
        ConeImgArray: An object containing cropped images and associated metadata.
            - view_id (int): The frame ID associated with the cropped images.
            - object_count (int): Number of cropped objects.
            - imgs (list of ConeImg): List of cropped images, where each ConeImg object contains:
                - detection_id (int): Identifier of the cropped detection.
                - rows (int): Number of rows (height) of the cropped image.
                - cols (int): Number of columns (width) of the cropped image.
                - img (sensor_msgs.msg.Image): ROS Image message containing the cropped image.
    """
    cropped_detections = ConeImgArray()

    cropped_detections.view_id = int(view_id)
    cropped_detections.object_count = len(boxes)
    cropped_detections.imgs = []

    for idx, box in enumerate(boxes):

        cropped_detection = ConeImg()

        cropped_detection.detection_id = idx
        cropped_detection.rows = box.shape[0]
        cropped_detection.cols = box.shape[1]

        xmin = int(box.xyxy[0][0])
        ymin = int(box.xyxy[0][1])
        xmax = int(box.xyxy[0][2])
        ymax = int(box.xyxy[0][3])
        
        cropped_img = img[ymin:ymax, xmin:xmax]
        cropped_detection.img = bridge.cv2_to_imgmsg(cropped_img, encoding="rgb8")

        cropped_detections.imgs.append(cropped_detection) 

    return cropped_detections